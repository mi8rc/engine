#include "file_io.h"
#include <string.h>
#include <ctype.h>

FileError g_last_file_error = FILE_ERROR_NONE;

const char *get_file_error_string(FileError error) {
    switch (error) {
        case FILE_ERROR_NONE: return "No error";
        case FILE_ERROR_NOT_FOUND: return "File not found";
        case FILE_ERROR_PERMISSION_DENIED: return "Permission denied";
        case FILE_ERROR_INVALID_FORMAT: return "Invalid file format";
        case FILE_ERROR_CORRUPTED_DATA: return "Corrupted data";
        case FILE_ERROR_UNSUPPORTED_VERSION: return "Unsupported version";
        case FILE_ERROR_MEMORY_ERROR: return "Memory allocation error";
        default: return "Unknown error";
    }
}

FileFormat detect_file_format(const char *filename) {
    if (!filename) return FILE_FORMAT_UNKNOWN;
    
    const char *ext = strrchr(filename, '.');
    if (!ext) return FILE_FORMAT_UNKNOWN;
    
    ext++; // Skip the dot
    
    if (g_ascii_strcasecmp(ext, "igs") == 0 || g_ascii_strcasecmp(ext, "iges") == 0) {
        return FILE_FORMAT_IGES;
    } else if (g_ascii_strcasecmp(ext, "stp") == 0 || g_ascii_strcasecmp(ext, "step") == 0) {
        return FILE_FORMAT_STEP;
    } else if (g_ascii_strcasecmp(ext, "obj") == 0) {
        return FILE_FORMAT_OBJ;
    } else if (g_ascii_strcasecmp(ext, "nme") == 0) { // NURBS Map Editor format
        return FILE_FORMAT_NATIVE;
    }
    
    return FILE_FORMAT_UNKNOWN;
}

gboolean save_file(const char *filename, GList *objects) {
    FileFormat format = detect_file_format(filename);
    
    switch (format) {
        case FILE_FORMAT_NATIVE:
            return save_native_format(filename, objects);
        case FILE_FORMAT_IGES:
            return save_iges_file(filename, objects);
        case FILE_FORMAT_OBJ:
            return export_obj_file(filename, objects);
        default:
            g_last_file_error = FILE_ERROR_INVALID_FORMAT;
            return FALSE;
    }
}

GList *load_file(const char *filename) {
    FileFormat format = detect_file_format(filename);
    
    switch (format) {
        case FILE_FORMAT_NATIVE:
            return load_native_format(filename);
        case FILE_FORMAT_IGES:
            return load_iges_file(filename);
        default:
            g_last_file_error = FILE_ERROR_INVALID_FORMAT;
            return NULL;
    }
}

// IGES Implementation
gboolean save_iges_file(const char *filename, GList *objects) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        g_last_file_error = FILE_ERROR_PERMISSION_DENIED;
        return FALSE;
    }
    
    // Write IGES header
    fprintf(file, "%-72sS%7d\n", "START", 1);
    fprintf(file, "1H,,1H;,4HNME,11HNURBS Editor,16H2024010100000000,32H%72sG%7d\n", "Generated by NURBS Map Editor", 1);
    fprintf(file, "15H20240101.000000,1.0,2HMM,1,0.0,15H20240101.000000,,,11,0,15H20%72sG%7d\n", "240101.000000", 2);
    
    int entity_count = 0;
    int param_line = 1;
    
    // Write directory entries and parameter data
    GList *current = objects;
    while (current) {
        MapObject *object = (MapObject*)current->data;
        
        if (object->type == OBJECT_CURVE && object->data.curve) {
            NurbsCurve *curve = object->data.curve;
            
            // Directory entry for NURBS curve (entity type 126)
            fprintf(file, "%8d%8d%8d%8d%8d%8d%8d%8d%8dD%7d\n",
                    126, param_line, 0, 0, 0, 0, 0, 0, 0, entity_count * 2 + 1);
            fprintf(file, "%8d%8d%8d%8d%8d%8s%8d%8dD%7d\n",
                    126, 0, 0, 0, 0, "", 0, 0, entity_count * 2 + 2);
            
            // Parameter data
            fprintf(file, "126,%d,%d,%d,%d,", curve->degree, curve->degree,
                    curve->num_control_points - 1, curve->num_control_points - 1);
            
            // Knot sequence
            for (int i = 0; i < curve->num_knots; i++) {
                fprintf(file, "%.6f", curve->knots[i]);
                if (i < curve->num_knots - 1) fprintf(file, ",");
            }
            fprintf(file, ",");
            
            // Weights (assuming all 1.0 for now)
            for (int i = 0; i < curve->num_control_points; i++) {
                fprintf(file, "%.6f", curve->control_points[i].w);
                if (i < curve->num_control_points - 1) fprintf(file, ",");
            }
            fprintf(file, ",");
            
            // Control points
            for (int i = 0; i < curve->num_control_points; i++) {
                fprintf(file, "%.6f,%.6f,%.6f",
                        curve->control_points[i].x,
                        curve->control_points[i].y,
                        curve->control_points[i].z);
                if (i < curve->num_control_points - 1) fprintf(file, ",");
            }
            
            fprintf(file, ",0.0,1.0,0,0;%72sP%7d\n", "", param_line);
            param_line++;
            entity_count++;
        }
        
        current = current->next;
    }
    
    // Terminate section
    fprintf(file, "S%7dG%7dD%7dP%7d%40sT%7d\n",
            1, 2, entity_count * 2, param_line - 1, "", 1);
    
    fclose(file);
    return TRUE;
}

static char *read_iges_line(FILE *file, char section) {
    char line[81];
    if (!fgets(line, sizeof(line), file)) return NULL;
    
    // Verify section identifier
    if (line[72] != section) return NULL;
    
    // Remove section identifier and sequence number
    line[72] = '\0';
    
    // Remove trailing whitespace
    char *end = line + strlen(line) - 1;
    while (end > line && isspace(*end)) {
        *end = '\0';
        end--;
    }
    
    return g_strdup(line);
}

GList *load_iges_file(const char *filename) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        g_last_file_error = FILE_ERROR_NOT_FOUND;
        return NULL;
    }
    
    GList *objects = NULL;
    char line[81];
    
    // Skip start section
    while (fgets(line, sizeof(line), file) && line[72] == 'S') {
        // Skip start section lines
    }
    
    // Skip global section
    while (line[72] == 'G') {
        if (!fgets(line, sizeof(line), file)) break;
    }
    
    // Read directory entries
    GList *directory_entries = NULL;
    while (line[72] == 'D') {
        IgesDirectoryEntry *entry = g_malloc0(sizeof(IgesDirectoryEntry));
        
        // Parse directory entry (simplified)
        sscanf(line, "%8d%8d%8d%8d%8d%8d%8d%8d%8d",
               &entry->entity_type,
               &entry->parameter_data_pointer,
               &entry->structure,
               &entry->line_font_pattern,
               &entry->level,
               &entry->view,
               &entry->transformation_matrix,
               &entry->label_display,
               &entry->status_number);
        
        directory_entries = g_list_append(directory_entries, entry);
        
        // Skip second line of directory entry
        if (!fgets(line, sizeof(line), file)) break;
        if (!fgets(line, sizeof(line), file)) break;
    }
    
    // Read parameter data and create objects
    GList *current_entry = directory_entries;
    while (line[72] == 'P' && current_entry) {
        IgesDirectoryEntry *entry = (IgesDirectoryEntry*)current_entry->data;
        
        if (entry->entity_type == 126) { // NURBS curve
            // Parse parameter data (simplified)
            char param_data[1024];
            strncpy(param_data, line, 72);
            param_data[72] = '\0';
            
            // Create NURBS curve from IGES data
            MapObject *object = parse_iges_nurbs_curve(param_data);
            if (object) {
                objects = g_list_append(objects, object);
            }
        }
        
        current_entry = current_entry->next;
        if (!fgets(line, sizeof(line), file)) break;
    }
    
    // Cleanup
    g_list_free_full(directory_entries, g_free);
    fclose(file);
    
    return objects;
}

static MapObject *parse_iges_nurbs_curve(const char *param_data) {
    // Simplified IGES NURBS curve parsing
    // In a real implementation, this would be much more comprehensive
    
    MapObject *object = map_object_new(OBJECT_CURVE, "IGES Curve");
    NurbsCurve *curve = nurbs_curve_new(3, 4); // Default values
    
    // Parse the parameter data string
    // Format: 126,K1,K2,M1,M2,knots,weights,control_points,start_param,end_param,unit_flag,periodic_flag;
    
    // This is a simplified parser - a full implementation would handle
    // all IGES formatting rules, continuation lines, etc.
    
    object->data.curve = curve;
    return object;
}

// Native format implementation (JSON-like)
gboolean save_native_format(const char *filename, GList *objects) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        g_last_file_error = FILE_ERROR_PERMISSION_DENIED;
        return FALSE;
    }
    
    fprintf(file, "{\n");
    fprintf(file, "  \"version\": \"1.0\",\n");
    fprintf(file, "  \"objects\": [\n");
    
    GList *current = objects;
    while (current) {
        MapObject *object = (MapObject*)current->data;
        
        fprintf(file, "    {\n");
        fprintf(file, "      \"name\": \"%s\",\n", object->name);
        fprintf(file, "      \"type\": \"%s\",\n", 
                object->type == OBJECT_CURVE ? "curve" : "surface");
        fprintf(file, "      \"visible\": %s,\n", object->visible ? "true" : "false");
        fprintf(file, "      \"position\": [%.6f, %.6f, %.6f],\n",
                object->position[0], object->position[1], object->position[2]);
        fprintf(file, "      \"rotation\": [%.6f, %.6f, %.6f],\n",
                object->rotation[0], object->rotation[1], object->rotation[2]);
        fprintf(file, "      \"scale\": [%.6f, %.6f, %.6f]", 
                object->scale[0], object->scale[1], object->scale[2]);
        
        if (object->type == OBJECT_CURVE && object->data.curve) {
            NurbsCurve *curve = object->data.curve;
            fprintf(file, ",\n      \"curve_data\": {\n");
            fprintf(file, "        \"degree\": %d,\n", curve->degree);
            fprintf(file, "        \"control_points\": [\n");
            
            for (int i = 0; i < curve->num_control_points; i++) {
                fprintf(file, "          [%.6f, %.6f, %.6f, %.6f]",
                        curve->control_points[i].x,
                        curve->control_points[i].y,
                        curve->control_points[i].z,
                        curve->control_points[i].w);
                if (i < curve->num_control_points - 1) fprintf(file, ",");
                fprintf(file, "\n");
            }
            
            fprintf(file, "        ],\n");
            fprintf(file, "        \"knots\": [");
            
            for (int i = 0; i < curve->num_knots; i++) {
                fprintf(file, "%.6f", curve->knots[i]);
                if (i < curve->num_knots - 1) fprintf(file, ", ");
            }
            
            fprintf(file, "]\n      }\n");
        }
        
        fprintf(file, "    }");
        if (current->next) fprintf(file, ",");
        fprintf(file, "\n");
        
        current = current->next;
    }
    
    fprintf(file, "  ]\n");
    fprintf(file, "}\n");
    
    fclose(file);
    return TRUE;
}

GList *load_native_format(const char *filename) {
    // Implementation would parse JSON-like format
    // For brevity, returning NULL here
    g_last_file_error = FILE_ERROR_UNSUPPORTED_VERSION;
    return NULL;
}

// OBJ export implementation
gboolean export_obj_file(const char *filename, GList *objects) {
    FILE *file = fopen(filename, "w");
    if (!file) {
        g_last_file_error = FILE_ERROR_PERMISSION_DENIED;
        return FALSE;
    }
    
    fprintf(file, "# Exported from NURBS Map Editor\n");
    fprintf(file, "# Object count: %d\n\n", g_list_length(objects));
    
    int vertex_offset = 1;
    
    GList *current = objects;
    while (current) {
        MapObject *object = (MapObject*)current->data;
        
        fprintf(file, "o %s\n", object->name);
        
        if (object->type == OBJECT_CURVE && object->data.curve) {
            NurbsCurve *curve = object->data.curve;
            
            // Tessellate curve if needed
            if (curve->dirty || !curve->vertices) {
                nurbs_curve_tessellate(curve, 100);
            }
            
            // Write vertices
            for (int i = 0; i < curve->num_vertices; i += 6) {
                fprintf(file, "v %.6f %.6f %.6f\n",
                        curve->vertices[i],
                        curve->vertices[i + 1],
                        curve->vertices[i + 2]);
            }
            
            // Write line segments
            for (int i = 0; i < curve->num_vertices / 6 - 1; i++) {
                fprintf(file, "l %d %d\n", vertex_offset + i, vertex_offset + i + 1);
            }
            
            vertex_offset += curve->num_vertices / 6;
        }
        
        fprintf(file, "\n");
        current = current->next;
    }
    
    fclose(file);
    return TRUE;
}